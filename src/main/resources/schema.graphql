scalar JSON
scalar Long

### Top-level Entities ###

type Pipeline @key(fields: "id") {
    id: ID!
    config: JSON
    nodes: [GraphNode]
    graphRunQueues: [GraphRunQueue]
    graphRuns: [GraphRun]
    graphEventQueues: [GraphEventQueue]
    graphEvents: [GraphEvent]
    logs: [GraphLog]
}

type GraphNode @key(fields: "id") {
    id: ID!
    config: JSON
    enabled: Boolean # is the node "turned on"
    capacity: Int # maximum runs allowed in running queue
    # workflow: Workflow @external # workflow registry?
    pipeline: Pipeline
    graphRunQueue: GraphRunQueue
    graphRuns: [GraphRun]
    graphEventQueues: [GraphEventQueue]
    graphEvents: [GraphEvent]
    logs: [GraphLog]
}

### QUEUE Types ###

type GraphRunQueue @key(fields: "id") {
    id: ID!
    exchange: String
    pipeline: Pipeline
    node: GraphNode
    graphRuns: [GraphRun]
    logs: [GraphLog]
}

type GraphEventQueue @key(fields: "id") {
    id: ID!
    exchange: String
    pipeline: Pipeline
    node: GraphNode
    graphEvents: [GraphEvent]
    logs: [GraphLog]
}

### Message Types ###

type GraphEvent @key(fields: "id") {
    id: ID!
    analysisId: ID
    analysisState: String
    analysisType: String
    studyId: String
    experimentalStrategy: String
    donorIds: [String]
    files: [AnalysisFile]
    pipeline: Pipeline
    node: GraphNode
    queue: GraphEventQueue
    logs: [GraphLog]
    analysis: Analysis
}

type AnalysisFile {
    dataType: String
}

type GraphRun @key(fields: "id") {
    id: ID!
    runId: ID
    pipeline: Pipeline
    node: GraphNode
    queue: GraphRunQueue
    logs: [GraphLog]
}

## Logs (for both GraphEvent and GraphRun)

type GraphLog @key(fields: "id") {
    id: ID!
    graphMessageId: ID
    log: String
    queue: GraphEventQueue
    node: GraphNode
    pipeline: Pipeline
    timestamp: Long
}

### Aggregations ###

type PipelineAggs {
    pipeline: Pipeline
    numNodes: Int
    queuedCount: Int
    runningCount: Int
    completeCount: Int
}

type NodeAggs {
    node: Node
    queuedCount: Int
    runningCount: Int
    completeCount: Int
}

# Stubbed external type (will come from Workflow Registry)
type Workflow @key(fields: "id") @extends {
    id: ID! @external
    repo: String
    schema: String
    running: [Run] # runs that are in the running queue(s) owned by this Pipeline/Node
}

# Stubbed external type (from Workflow Search)
type Run @key(fields: "runId") @extends {
    runId: ID! @external
    pipeline: Pipeline @requires(fields: "workflow")
    node: Node @requires(fields: "workflow")
}

# Stubbed external type (from Song Search)
type Analysis @key(fields: "analysisId") @extends {
    analysisId: ID! @external
    pipeline: Pipeline
    node: Node
}

# temp filter that does nothing currently
input StubFilter {
    id: ID
}

# TBD, could be improved following what happens in other services
input Page {
    size: Int!
    from: Int!
}

# TBD if we want all these queries and what filters they would provide
extend type Query {
    pipelines(filter: StubFilter, page: Page): [Pipeline]
    graphNodes(filter: StubFilter, page: Page): [GraphNode]
    graphRunQueues(filter: StubFilter, page: Page): [GraphRunQueue]
    graphEventQueues(filter: StubFilter, page: Page): [GraphEventQueue]
    graphRuns(filter: StubFilter, page: Page): [GraphRun]
    graphEvents(filter: StubFilter, page: Page): [GraphEvent]
    graphLogs(filter: StubFilter, page: Page): [GraphLog]
    pipelineAggs: PipelineAggs
    nodeAggs: NodeAggs
}